<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>test3</title>
      <link href="/2024/06/22/test/"/>
      <url>/2024/06/22/test/</url>
      
        <content type="html"><![CDATA[<p>这是一个测试</p>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop</title>
      <link href="/2024/06/21/hadoop/"/>
      <url>/2024/06/21/hadoop/</url>
      
        <content type="html"><![CDATA[<p>Hadoop 是一个用于分布式存储和处理大规模数据的开源框架，主要包括 Hadoop 分布式文件系统（HDFS）和 MapReduce 编程模型。下面将深入讲解 Hadoop 的工作原理和架构。</p><h3 id="Hadoop-的作用"><a href="#Hadoop-的作用" class="headerlink" title="Hadoop 的作用"></a>Hadoop 的作用</h3><p>Hadoop 的作用非常简单，就是在多计算机集群环境中营造一个统一而稳定的存储和计算环境，并能为其他分布式应用服务提供平台支持。</p><p>也就是说， Hadoop 在某种程度上将多台计算机组织成了一台计算机（做同一件事），那么 HDFS 就相当于这台计算机的硬盘，而 MapReduce 就是这台计算机的 CPU 控制器。</p><h3 id="Hadoop-架构概述"><a href="#Hadoop-架构概述" class="headerlink" title="Hadoop 架构概述"></a>Hadoop 架构概述</h3><p>Hadoop 的核心组件包括：</p><ol><li><strong>Hadoop 分布式文件系统 (HDFS)</strong>：负责存储大量数据。</li><li><strong>MapReduce</strong>：一种分布式计算模型，用于处理和生成大规模数据集。</li><li><strong>YARN (Yet Another Resource Negotiator)</strong>：负责资源管理和任务调度。</li></ol><h4 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h4><p>HDFS 是一个分布式文件系统，设计用于在廉价硬件上存储超大规模数据。它具有高容错性和高吞吐量的特点。</p><p><strong>HDFS 的核心组件：</strong></p><ol><li><strong>NameNode</strong>：负责管理HDFS的元数据，不存储实际数据。HDFS 的主节点，负责管理文件系统的元数据，比如文件名、目录结构、以及每个文件的块位置。它不存储实际的数据，只存储元数据。</li><li><strong>DataNode</strong>：负责存储实际的数据块，并执行对这些块的读写操作。数据节点，负责实际存储数据块，并定期向 NameNode 报告其状态。</li></ol><p><strong>HDFS 的工作机制：</strong></p><ul><li>文件在 HDFS 中被分割成固定大小的块（通常为 128MB 或 256MB），每个块在多个 DataNode 之间复制（通常为 3 个副本）以保证容错性。</li><li>当客户端要读取文件时，首先与 NameNode 通信获取文件块的位置信息，然后直接从相应的 DataNode 读取数据。</li></ul><h4 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h4><p>MapReduce 是一种编程模型，允许用户在分布式环境中处理大规模数据集。它包括两个主要阶段：Map 阶段和 Reduce 阶段。</p><p><strong>MapReduce 的核心组件：</strong></p><ol><li><strong>JobTracker（在 Hadoop 1.x）</strong>：负责任务的调度和监控。Hadoop 2.x 引入了 YARN 后，JobTracker 的职责被拆分成 ResourceManager 和 ApplicationMaster。</li><li><strong>TaskTracker（在 Hadoop 1.x）</strong>：负责在各个节点上执行任务。Hadoop 2.x 引入了 NodeManager 代替 TaskTracker。</li></ol><p><strong>MapReduce 的工作机制：</strong></p><ul><li><strong>Map 阶段</strong>：输入数据被分割成多个块，每个块被分配给一个 Map 任务。Map 任务处理输入数据，生成一组中间键值对。</li><li><strong>Shuffle and Sort 阶段</strong>：Map 阶段的输出被分区，并按照键进行排序，然后传递给相应的 Reduce 任务。</li><li><strong>Reduce 阶段</strong>：Reduce 任务对中间键值对进行处理，生成最终的输出结果。</li></ul><h3 id="YARN-Yet-Another-Resource-Negotiator"><a href="#YARN-Yet-Another-Resource-Negotiator" class="headerlink" title="YARN (Yet Another Resource Negotiator)"></a>YARN (Yet Another Resource Negotiator)</h3><p>YARN 是 Hadoop 2.x 中的资源管理系统，旨在改进 Hadoop 的可扩展性和资源利用率。</p><p><strong>YARN 的核心组件：</strong></p><ol><li><strong>ResourceManager</strong>：负责整个系统的资源管理和任务调度。它包括两个主要部分：调度器和应用管理器。</li><li><strong>NodeManager</strong>：负责每个节点的资源管理和任务执行。</li><li><strong>ApplicationMaster</strong>：每个应用程序都有一个 ApplicationMaster，负责协调该应用程序在集群中的执行，包括分配资源和任务调度。</li></ol><p><strong>YARN 的工作机制：</strong></p><ul><li>当用户提交一个应用程序时，YARN 启动一个 ApplicationMaster 来管理这个应用程序的生命周期。</li><li>ResourceManager 分配资源给 ApplicationMaster，ApplicationMaster 根据需要启动 Container（任务执行的基本单位），并在这些 Container 上运行任务。</li><li>NodeManager 监控 Container 的资源使用情况，并定期向 ResourceManager 报告。</li></ul><h3 id="Hadoop-的数据流和执行过程"><a href="#Hadoop-的数据流和执行过程" class="headerlink" title="Hadoop 的数据流和执行过程"></a>Hadoop 的数据流和执行过程</h3><ol><li><strong>数据写入 HDFS</strong>：用户通过 HDFS 客户端将数据写入 HDFS。客户端将数据分块，并将每个块写入多个 DataNode。NameNode 记录每个块的元数据。</li><li><strong>提交 MapReduce 作业</strong>：用户通过客户端提交 MapReduce 作业。ResourceManager 接收作业并启动 ApplicationMaster。</li><li><strong>任务调度和执行</strong>：ApplicationMaster 向 ResourceManager 请求资源并启动 Container。Map 任务读取 HDFS 中的数据，进行处理，并输出中间键值对。Reduce 任务接收中间数据，进行处理，生成最终结果并写回 HDFS。</li><li><strong>结果存储和读取</strong>：用户可以通过 HDFS 客户端读取作业生成的最终结果。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Hadoop 通过 HDFS 提供可靠的分布式存储，通过 MapReduce 提供强大的分布式计算能力，并通过 YARN 实现灵活高效的资源管理。这些组件协同工作，使 Hadoop 成为处理大规模数据的强大工具。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>REST控制器</title>
      <link href="/2024/05/28/REST%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
      <url>/2024/05/28/REST%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>REST 控制器是用于构建基于 REST 架构风格的 Web 服务的一部分。REST（Representational State Transfer）是一种基于 HTTP 协议的网络架构风格，它定义了一组约束和属性，通过使用一小组标准操作（如 GET、POST、PUT、DELETE）进行数据操作。Spring Boot 提供了方便的注解和工具，使得创建 RESTful Web 服务变得非常简单。</p><h3 id="REST-控制器的核心概念"><a href="#REST-控制器的核心概念" class="headerlink" title="REST 控制器的核心概念"></a>REST 控制器的核心概念</h3><ol><li><strong>资源（Resource）</strong>：<ul><li>在 REST 架构中，资源是网络上的实体，通常通过 URI（统一资源标识符）来标识。每个资源都有一个唯一的 URI。</li></ul></li><li><strong>HTTP 方法</strong>：<ul><li>REST 使用标准的 HTTP 方法来执行操作。常用的 HTTP 方法有：<ul><li><strong>GET</strong>：从服务器获取资源。</li><li><strong>POST</strong>：向服务器创建一个新的资源。</li><li><strong>PUT</strong>：更新服务器上的资源。</li><li><strong>DELETE</strong>：删除服务器上的资源。</li></ul></li></ul></li><li><strong>表示（Representation）</strong>：<ul><li>资源的表示是将资源的状态传输给客户端的一种方式，通常是 JSON 或 XML 格式。</li></ul></li><li><strong>无状态（Stateless）</strong>：<ul><li>每个请求都必须包含处理该请求所需的所有信息，服务器不应该在两个请求之间存储客户端的状态。</li></ul></li></ol><h3 id="Spring-Boot-中的-REST-控制器"><a href="#Spring-Boot-中的-REST-控制器" class="headerlink" title="Spring Boot 中的 REST 控制器"></a>Spring Boot 中的 REST 控制器</h3><p>在 Spring Boot 中，REST 控制器是一个带有 <code>@RestController</code> 注解的类，它处理 HTTP 请求并返回响应。该类中的每个方法都可以映射到一个特定的 HTTP 请求路径和方法。</p><h3 id="关键注解"><a href="#关键注解" class="headerlink" title="关键注解"></a>关键注解</h3><ul><li><strong><code>@RestController</code></strong>：<ul><li>标记一个类为 Spring MVC 的控制器，并且每个方法返回的对象会被自动转换为 JSON 格式，直接写入 HTTP 响应体。</li></ul></li><li><strong><code>@GetMapping</code></strong>：<ul><li>映射 HTTP GET 请求到指定的方法。</li></ul></li><li><strong><code>@PostMapping</code></strong>：<ul><li>映射 HTTP POST 请求到指定的方法。</li></ul></li><li><strong><code>@PutMapping</code></strong>：<ul><li>映射 HTTP PUT 请求到指定的方法。</li></ul></li><li><strong><code>@DeleteMapping</code></strong>：<ul><li>映射 HTTP DELETE 请求到指定的方法。</li></ul></li></ul><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>下面是一个简单的 Spring Boot REST 控制器示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PutMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.DeleteMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItemController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; items = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/items&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getItems</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/items&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addItem</span><span class="params">(<span class="meta">@RequestBody</span> String item)</span> &#123;</span><br><span class="line">        items.add(item);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Item added&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/items/&#123;index&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">updateItem</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> index, <span class="meta">@RequestBody</span> String newItem)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; items.size()) &#123;</span><br><span class="line">            items.set(index, newItem);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Item updated&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Item not found&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/items/&#123;index&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deleteItem</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; items.size()) &#123;</span><br><span class="line">            items.remove(index);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Item deleted&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Item not found&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h3><ul><li><strong>类和包</strong>：<ul><li><code>package com.example.demo;</code> 声明类的包路径。</li><li><code>public class ItemController</code> 定义了一个名为 <code>ItemController</code> 的公共类。</li></ul></li><li><strong>注解</strong>：<ul><li><code>@RestController</code> 表明该类是一个 REST 控制器，方法返回的对象会自动转换为 JSON。</li></ul></li><li><strong>字段</strong>：<ul><li><code>private List&lt;String&gt; items = new ArrayList&lt;&gt;();</code> 定义了一个存储字符串的列表，用来模拟数据存储。</li></ul></li><li><strong>方法</strong>：<ul><li><code>@GetMapping(&quot;/items&quot;)</code>：处理 GET 请求，返回所有项目。</li><li><code>@PostMapping(&quot;/items&quot;)</code>：处理 POST 请求，接收请求体中的数据并添加到 <code>items</code> 列表中。</li><li><code>@PutMapping(&quot;/items/&#123;index&#125;&quot;)</code>：处理 PUT 请求，更新指定索引的项目。</li><li><code>@DeleteMapping(&quot;/items/&#123;index&#125;&quot;)</code>：处理 DELETE 请求，删除指定索引的项目。</li></ul></li></ul><p>通过这些示例和讲解，你应该能够理解 REST 控制器的基本概念以及如何在 Spring Boot 中实现一个简单的 RESTful API。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> REST控制器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spingboot</title>
      <link href="/2024/05/28/springboot/"/>
      <url>/2024/05/28/springboot/</url>
      
        <content type="html"><![CDATA[<p>Spring Boot 是一个基于 Spring 框架的开源项目，用于简化 Spring 应用程序开发。它通过提供默认配置和预先配置的设置，使得开发生产级别的应用程序更加容易和快速。</p><h2 id="Spring-Boot-的主要特性"><a href="#Spring-Boot-的主要特性" class="headerlink" title="Spring Boot 的主要特性"></a>Spring Boot 的主要特性</h2><ol><li><strong>自动配置 (Auto-Configuration)</strong>： Spring Boot 可以根据项目中包含的依赖自动配置 Spring 应用程序，这减少了大量的手动配置工作。</li><li><strong>独立运行 (Standalone)</strong>： Spring Boot 应用程序可以打包成 JAR 文件并且可以直接运行，不需要外部的应用服务器。这是通过内嵌的 Tomcat、Jetty 或者 Undertow 实现的。</li><li><strong>生产准备 (Production-Ready)</strong>： Spring Boot 提供了多种生产环境的特性，如监控、健康检查和外部化配置等，这使得应用程序更易于部署和维护。</li><li><strong>简化的构建和开发 (Simplified Build and Development)</strong>： 使用 Spring Boot，可以通过简化的项目设置和减少的配置来加快开发过程。常见的开发任务（如依赖管理、测试和部署）变得更加简便。</li><li><strong>Spring Boot Starter</strong>： Spring Boot 提供了一系列预定义的 “starter” 依赖集合，开发者可以根据需要选择不同的 starter，这些 starter 包含了构建特定类型应用程序所需的所有依赖。</li></ol><p>这段代码是一个使用Spring Boot构建的简单REST控制器，定义了一个RESTful API的端点。以下是对代码的详细分析和讲解：</p><h3 id="分析代码"><a href="#分析代码" class="headerlink" title="分析代码"></a>分析代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tutorial.bootdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> List.of(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h3><ol><li><p><strong>包声明</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tutorial.bootdemo;</span><br></pre></td></tr></table></figure><ul><li>定义了这个类所在的包。Java中的包用于组织类和接口，防止命名冲突。</li></ul></li><li><p><strong>导入语句</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br></pre></td></tr></table></figure><ul><li><code>GetMapping</code> 和 <code>RestController</code> 是Spring Web中的注解，分别用于映射HTTP GET请求和标识REST控制器。</li><li><code>List</code> 是Java集合框架中的接口，代表一个有序的集合。</li></ul></li><li><p><strong>类声明和注解</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br></pre></td></tr></table></figure><ul><li><code>@RestController</code> 注解表示这是一个Spring MVC的控制器，它处理HTTP请求并且返回的数据会直接写入HTTP响应体（通常是JSON格式）。</li><li><code>public class TestController</code> 声明了一个名为<code>TestController</code>的公共类。</li></ul></li><li><p><strong>方法声明和注解</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> List.of(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>@GetMapping(&quot;/hello&quot;)</code> 注解用于将HTTP GET请求映射到 <code>hello</code> 方法，路径为 <code>/hello</code>。</li><li><code>public List&lt;String&gt; hello()</code> 声明了一个返回类型为 <code>List&lt;String&gt;</code> 的公共方法 <code>hello</code>。</li><li><code>return List.of(&quot;hello&quot;, &quot;world&quot;);</code> 返回一个包含 “hello” 和 “world” 的列表。<code>List.of</code> 是Java 9引入的一个方便的方法，用于创建不可变的列表。<h2 id="spring-boot程序层次"><a href="#spring-boot程序层次" class="headerlink" title="spring boot程序层次"></a>spring boot程序层次</h2>在Spring Boot框架中，应用程序通常分为多个层次，每个层次都有特定的职责和功能。常见的分层结构包括DAO层、Service层和Controller层等。以下是每个层的详细功能：</li></ul></li></ol><h3 id="1-Controller-层"><a href="#1-Controller-层" class="headerlink" title="1. Controller 层"></a>1. Controller 层</h3><p><strong>功能：</strong></p><ul><li>处理HTTP请求并返回响应。</li><li>负责将客户端请求分发到适当的Service层方法。</li><li>进行简单的数据验证。</li><li>将业务逻辑结果封装为HTTP响应返回给客户端。</li></ul><p><strong>示例代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title function_">getUserById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findUserById(id);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/users&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title function_">createUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">createdUser</span> <span class="operator">=</span> userService.saveUser(user);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(HttpStatus.CREATED).body(createdUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Service-层"><a href="#2-Service-层" class="headerlink" title="2. Service 层"></a>2. Service 层</h3><p><strong>功能：</strong></p><ul><li>包含业务逻辑。</li><li>从DAO层获取数据，并进行业务处理。</li><li>处理事务逻辑（例如，开始和提交事务）。</li><li>将处理后的数据返回给Controller层。</li></ul><p><strong>示例代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findUserById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.findById(id).orElse(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">saveUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.save(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更多业务方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-DAO-层（Repository-层）"><a href="#3-DAO-层（Repository-层）" class="headerlink" title="3. DAO 层（Repository 层）"></a>3. DAO 层（Repository 层）</h3><p><strong>功能：</strong></p><ul><li>直接与数据库进行交互。</li><li>执行CRUD操作（创建、读取、更新、删除）。</li><li>通常使用Spring Data JPA或其他持久化框架来简化数据库操作。</li></ul><p><strong>示例代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">    <span class="comment">// 可以定义自定义查询方法，例如：</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findByLastName</span><span class="params">(String lastName)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Model-层（实体层）"><a href="#4-Model-层（实体层）" class="headerlink" title="4. Model 层（实体层）"></a>4. Model 层（实体层）</h3><p><strong>功能：</strong></p><ul><li>定义应用程序的核心数据结构。</li><li>与数据库表结构映射。</li><li>包含字段、关系和数据验证注解。</li></ul><p><strong>示例代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-DTO-层（可选）"><a href="#5-DTO-层（可选）" class="headerlink" title="5. DTO 层（可选）"></a>5. DTO 层（可选）</h3><p><strong>功能：</strong></p><ul><li>数据传输对象，用于在不同层之间传递数据。</li><li>封装复杂的数据结构，避免直接暴露实体对象。</li><li>可以通过DTO进行输入输出数据的转换和验证。</li></ul><p><strong>示例代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDTO</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-配置层（可选）"><a href="#6-配置层（可选）" class="headerlink" title="6. 配置层（可选）"></a>6. 配置层（可选）</h3><p><strong>功能：</strong></p><ul><li>配置应用程序的各项设置，如数据库配置、安全配置等。</li><li>通过注解和Java类定义配置项。</li></ul><p><strong>示例代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ModelMapper <span class="title function_">modelMapper</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ModelMapper</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-异常处理层（可选）"><a href="#7-异常处理层（可选）" class="headerlink" title="7. 异常处理层（可选）"></a>7. 异常处理层（可选）</h3><p><strong>功能：</strong></p><ul><li>统一处理应用程序中的异常。</li><li>向客户端返回一致的错误响应。</li></ul><p><strong>示例代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(ResourceNotFoundException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;ErrorResponse&gt; <span class="title function_">handleResourceNotFoundException</span><span class="params">(ResourceNotFoundException ex)</span> &#123;</span><br><span class="line">        <span class="type">ErrorResponse</span> <span class="variable">errorResponse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorResponse</span>(HttpStatus.NOT_FOUND.value(), ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(errorResponse, HttpStatus.NOT_FOUND);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更多异常处理方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种分层结构，可以提高代码的可维护性、可读性和可扩展性，同时也使得职责更加清晰，每个层次专注于处理特定的任务。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="JpaRepository继承链中的重要方法"><a href="#JpaRepository继承链中的重要方法" class="headerlink" title="JpaRepository继承链中的重要方法"></a><code>JpaRepository</code>继承链中的重要方法</h3><ul><li><code>save(S entity)</code>：保存或更新实体。</li><li><code>findById(ID id)</code>：根据ID查找实体。</li><li><code>findAll()</code>：查找所有实体。</li><li><code>deleteById(ID id)</code>：根据ID删除实体。</li><li><code>count()</code>：统计实体的数量。</li></ul><h3 id="自定义查询方法"><a href="#自定义查询方法" class="headerlink" title="自定义查询方法"></a>自定义查询方法</h3><p>Spring Data JPA可以根据方法名自动生成查询。你的接口中定义的自定义查询方法有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User <span class="title function_">findByUsername</span><span class="params">(String username)</span>;</span><br><span class="line">User <span class="title function_">findByEmail</span><span class="params">(String email)</span>;</span><br></pre></td></tr></table></figure><p>这些方法会自动生成相应的SQL查询，比如：</p><ul><li><code>findByUsername(String username)</code>会生成类似于<code>SELECT * FROM users WHERE username = ?</code>的查询。</li><li><code>findByEmail(String email)</code>会生成类似于<code>SELECT * FROM users WHERE email = ?</code>的查询。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spingboot相关注解</title>
      <link href="/2024/05/28/springboot%E6%B3%A8%E8%A7%A3/"/>
      <url>/2024/05/28/springboot%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h2><p><code>@RestController</code> 是 Spring 框架中的一个注解，用于构建 RESTful Web 服务。当你将一个类标记为 <code>@RestController</code> 时，Spring 会理解这个类将处理 HTTP 请求，并以 RESTful 的方式返回响应。以下是详细介绍：</p><ol><li><p><strong>用途</strong>：<code>@RestController</code> 的主要目的是简化开发 RESTful Web 服务的过程。它结合了 <code>@Controller</code> 和 <code>@ResponseBody</code> 注解的功能。</p></li><li><p><strong>RequestMapping</strong>：当你将一个类标记为 <code>@RestController</code> 时，通常会与 <code>@RequestMapping</code>、<code>@GetMapping</code>、<code>@PostMapping</code> 等一起使用，以定义 HTTP 请求的 URL 映射。</p></li><li><p><strong>响应</strong>：<code>@RestController</code> 注解的类中的方法直接返回对象，Spring 会根据请求的 <code>Accept</code> 头自动将其转换为 JSON 或 XML 响应。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, world!&quot;</span>;java</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，当对 <code>/hello</code> 发起 GET 请求时，<code>hello()</code> 方法会被调用，并将 “Hello, world!” 作为响应返回。</p></li><li><p><strong>优点</strong>：</p><ul><li>简化了开发 RESTful API 的过程，无需在每个方法上使用 <code>@ResponseBody</code> 注解。</li><li>自动将响应转换为 JSON 或 XML。</li><li>提供了一种清晰简洁的方式来定义 RESTful 端点。</li></ul></li><li><p><strong>注意事项</strong>：</p><ul><li><code>@RestController</code> 通常用于响应是数据本身（JSON、XML 等）的 API。</li><li>如果需要返回视图（HTML 页面），应该使用 <code>@Controller</code>。</li></ul></li><li><p><strong>集成</strong>：<code>@RestController</code> 是 Spring MVC 的核心组件，广泛用于 Java Web 开发，用于构建 Web 应用程序和 RESTful API。</p></li></ol><p>总的来说，<code>@RestController</code> 简化了在 Spring 框架中创建 RESTful 服务的过程，使开发人员更容易构建可扩展和可维护的 API。</p><h2 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h2><p><code>@RequestMapping</code> 是 Spring 框架中用于映射 HTTP 请求到处理器方法的注解。它可以用在类级别和方法级别上，用于定义请求的 URL 映射规则。以下是 <code>@RequestMapping</code> 的详细介绍：</p><ol><li><p><strong>类级别使用</strong>：你可以将 <code>@RequestMapping</code> 注解直接放在类的定义上，用于指定该类中所有方法的基本 URL 路径。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/example&quot;)</span><br><span class="line">public class ExampleController &#123;</span><br><span class="line">    // Methods...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，所有在 <code>ExampleController</code> 类中定义的方法都将映射到以 <code>/example</code> 开头的 URL 上。</p></li><li><p><strong>方法级别使用</strong>：你也可以将 <code>@RequestMapping</code> 注解放在方法上，用于进一步定义方法处理的具体 URL 和 HTTP 请求类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/example&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>hello()</code> 方法将处理 GET 请求 <code>/example/hello</code>。</p></li><li><p><strong>支持的属性</strong>：<code>@RequestMapping</code> 注解支持多种属性，包括：</p><ul><li><code>value</code> 或 <code>path</code>：指定 URL 映射路径。</li><li><code>method</code>：指定 HTTP 请求方法。</li><li><code>params</code>：指定请求参数的条件。</li><li><code>headers</code>：指定请求头的条件。</li><li><code>consumes</code>：指定请求的内容类型。</li><li><code>produces</code>：指定响应的内容类型。</li></ul></li><li><p><strong>请求方法</strong>：<code>@RequestMapping</code> 注解支持的 HTTP 请求方法包括 <code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code>、<code>PATCH</code> 等。</p></li><li><p><strong>通配符和占位符</strong>：<code>@RequestMapping</code> 支持使用通配符 <code>*</code> 和 <code>**</code>，以及占位符 <code>&#123;&#125;</code>。</p></li><li><p><strong>整合其他注解</strong>：<code>@RequestMapping</code> 注解可以与其他注解（如 <code>@GetMapping</code>、<code>@PostMapping</code> 等）一起使用，以提高代码的可读性和语义性。</p></li></ol><p><code>@RequestMapping</code> 注解是 Spring MVC 中最重要的注解之一，它为开发者提供了灵活的方式来映射 HTTP 请求到相应的处理器方法，从而构建功能丰富的 Web 应用程序和 RESTful API。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue</title>
      <link href="/2024/05/28/vue/"/>
      <url>/2024/05/28/vue/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue项目工程的介绍"><a href="#Vue项目工程的介绍" class="headerlink" title="Vue项目工程的介绍"></a>Vue项目工程的介绍</h2><p>public：放静态文件的地方，比如html、静态图标等等<br>src：项目的源码目录<br>src.assets：可以放一些logo、图片、自定义样式啥的<br>src.components：vue组件<br>src.router：定义路由，每个路由对应一个页面<br>src.views：视图文件<br>App.vue：所有页面的入口<br>main.js：所有配置的入口，可以导入项目所需要的包，然后组合在一起<br>vue.config.js：vue项目里的一些配置，可以配置端口、跨域等等</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++标准库介绍</title>
      <link href="/2024/05/23/cpp/"/>
      <url>/2024/05/23/cpp/</url>
      
        <content type="html"><![CDATA[<p>C++标准库（Standard Library）是C++编程语言的重要组成部分，它提供了大量的函数、类和模板，用于各种常见的编程任务，如输入输出、字符串处理、数据结构和算法等。C++标准库使得编写高效、可维护和可移植的程序变得更加容易。</p><p>以下是C++标准库的一些主要组件和头文件：</p><h3 id="基础输入输出流"><a href="#基础输入输出流" class="headerlink" title="基础输入输出流"></a>基础输入输出流</h3><ul><li><p><strong><code>&lt;iostream&gt;</code></strong>: 提供输入输出流，如<code>std::cin</code>, <code>std::cout</code>, <code>std::cerr</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>&lt;iomanip&gt;</code></strong>: 提供输入输出流的格式控制，如设置宽度、填充字符等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">std::cout &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="number">42</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>&lt;fstream&gt;</code></strong>: 提供文件输入输出流，如<code>std::ifstream</code>, <code>std::ofstream</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="function">std::ofstream <span class="title">outfile</span><span class="params">(<span class="string">&quot;example.txt&quot;</span>)</span></span>;</span><br><span class="line">outfile &lt;&lt; <span class="string">&quot;Writing to a file&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure></li></ul><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><ul><li><p><strong><code>&lt;vector&gt;</code></strong>: 动态数组，提供随机访问和动态调整大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>&lt;list&gt;</code></strong>: 双向链表，提供高效的插入和删除操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line">std::list&lt;<span class="type">int</span>&gt; lst = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>&lt;deque&gt;</code></strong>: 双端队列，提供快速的头尾插入和删除操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line">std::deque&lt;<span class="type">int</span>&gt; dq = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>&lt;array&gt;</code></strong>: 定长数组，提供数组的基本功能。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line">std::array&lt;<span class="type">int</span>, 4&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>&lt;set&gt;</code></strong>: 集合，提供唯一性和有序性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line">std::set&lt;<span class="type">int</span>&gt; s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>&lt;map&gt;</code></strong>: 映射，提供键值对存储和快速查找。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line">std::map&lt;<span class="type">int</span>, std::string&gt; m = &#123;&#123;<span class="number">1</span>, <span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="number">2</span>, <span class="string">&quot;two&quot;</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul><li><p><strong><code>&lt;algorithm&gt;</code></strong>: 提供一系列通用算法，如排序、查找、变换等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure></li><li><p><strong><code>&lt;numeric&gt;</code></strong>: 提供一些常用的数值算法，如累加、内积等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> sum = std::<span class="built_in">accumulate</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="字符串和正则表达式"><a href="#字符串和正则表达式" class="headerlink" title="字符串和正则表达式"></a>字符串和正则表达式</h3><ul><li><p><strong><code>&lt;string&gt;</code></strong>: 提供字符串类<code>std::string</code>和相关函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line">std::string str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>&lt;regex&gt;</code></strong>: 提供正则表达式的支持。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="function">std::regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;[a-z]+&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">bool</span> match = std::<span class="built_in">regex_match</span>(<span class="string">&quot;hello&quot;</span>, pattern);</span><br></pre></td></tr></table></figure></li></ul><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><ul><li><strong><code>&lt;memory&gt;</code></strong>: 提供智能指针，如<code>std::shared_ptr</code>, <code>std::unique_ptr</code>, <code>std::weak_ptr</code>。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="线程和并发"><a href="#线程和并发" class="headerlink" title="线程和并发"></a>线程和并发</h3><ul><li><p><strong><code>&lt;thread&gt;</code></strong>: 提供线程支持。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from thread!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(thread_function)</span></span>;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure></li><li><p><strong><code>&lt;mutex&gt;</code></strong>: 提供互斥锁和同步原语。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line">std::mutex mtx;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>&lt;future&gt;</code></strong>: 提供异步操作和期望值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line">std::future&lt;<span class="type">int</span>&gt; fut = std::<span class="built_in">async</span>(std::launch::async, []() &#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;);</span><br><span class="line"><span class="type">int</span> result = fut.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure></li></ul><h3 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h3><ul><li><strong><code>&lt;chrono&gt;</code></strong>: 提供时间和日期处理。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="comment">// some operations</span></span><br><span class="line"><span class="keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="keyword">auto</span> duration = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(end - start).<span class="built_in">count</span>();</span><br></pre></td></tr></table></figure></li></ul><h3 id="数学和随机数"><a href="#数学和随机数" class="headerlink" title="数学和随机数"></a>数学和随机数</h3><ul><li><p><strong><code>&lt;cmath&gt;</code></strong>: 提供数学函数，如<code>sqrt</code>, <code>pow</code>, <code>sin</code>, <code>cos</code>等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="type">double</span> result = std::<span class="built_in">sqrt</span>(<span class="number">16.0</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong><code>&lt;random&gt;</code></strong>: 提供随机数生成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line">std::random_device rd;</span><br><span class="line"><span class="function">std::mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>;</span><br><span class="line">std::uniform_int_distribution&lt;&gt; <span class="built_in">dis</span>(<span class="number">1</span>, <span class="number">6</span>);</span><br><span class="line"><span class="type">int</span> random_number = <span class="built_in">dis</span>(gen);</span><br></pre></td></tr></table></figure></li></ul><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ul><li><strong><code>&lt;exception&gt;</code></strong>: 提供异常类和处理函数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;An error occurred&quot;</span>);</span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Caught exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这些只是C++标准库的一部分。完整的C++标准库非常庞大，涵盖了从基础到高级的各种功能模块。学习和使用这些标准库可以大大提高你的编程效率和代码质量。</p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git相关</title>
      <link href="/2024/05/23/git/"/>
      <url>/2024/05/23/git/</url>
      
        <content type="html"><![CDATA[<h2 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p><strong>获取仓库 URL</strong>：</p><ul><li>登录到你的 GitHub 账号。</li><li>导航到你要克隆的项目页面。</li><li>点击页面右上角的绿色 “Code” 按钮，会弹出一个下拉菜单，里面有项目的 HTTPS 和 SSH URL。选择 HTTPS 或 SSH URL 并复制。</li></ul></li><li><p><strong>打开终端或命令行</strong>：</p><ul><li>在你的电脑上打开终端（Mac 和 Linux 用户）或命令行（Windows 用户）。</li></ul></li><li><p><strong>导航到目标目录</strong>：</p><ul><li><p>使用 cd命令导航到你希望存放项目的目录。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/to/your/directory</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>克隆仓库</strong>：</p><ul><li><p>使用 git clone命令将项目克隆到本地。将 repository-url替换为你在步骤 1 中复制的仓库 URL。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/your-username/your-repository.git</span><br></pre></td></tr></table></figure><p>或者，如果你使用 SSH：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:your-username/your-repository.git</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>进入项目目录</strong>：</p><ul><li><p>克隆完成后，Git 会在当前目录下创建一个与你仓库同名的文件夹。使用cd命令进入该文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> your-repository</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>验证克隆</strong>：</p><ul><li><p>使用 git status命令确认仓库已正确克隆并显示当前状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li><strong>认证问题</strong>：如果你使用 HTTPS URL，可能需要输入 GitHub 账号的用户名和密码。如果你设置了双因素认证，你需要生成一个 <a href="https://github.com/settings/tokens">GitHub 个人访问令牌</a> 作为密码使用。使用 SSH URL 时，需要配置 SSH 密钥对。</li><li><strong>设置远程仓库</strong>：克隆操作会自动设置远程仓库（通常命名为 <code>origin</code>）。你可以使用 <code>git remote -v</code> 查看配置的远程仓库 URL。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>认证问题</strong>：如果你使用 HTTPS URL，可能需要输入 GitHub 账号的用户名和密码。如果你设置了双因素认证，你需要生成一个 <a href="https://github.com/settings/tokens">GitHub 个人访问令牌</a> 作为密码使用。使用 SSH URL 时，需要配置 SSH 密钥对。</li><li><strong>设置远程仓库</strong>：克隆操作会自动设置远程仓库（通常命名为 <code>origin</code>）。你可以使用 <code>git remote -v</code> 查看配置的远程仓库 URL。</li></ul><p>通过这些步骤，你应该能够成功从 GitHub 获取自己的项目并在本地进行开发和管理。</p><h4 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h4><p>使用 <code>git pull</code> 也可以将 GitHub 上的项目获取到本地，但前提是你已经在本地初始化了一个 Git 仓库，并配置了指向 GitHub 仓库的远程仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化一个新的 Git 仓库</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加远程仓库</span></span><br><span class="line">git remote add origin https://github.com/your-username/my-project.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取远程仓库内容</span></span><br><span class="line"><span class="comment"># 这里假设远程仓库的默认分支是 main。如果你的默认分支是 master 或其他名称，请相应地更改命令中的分支名。</span></span><br><span class="line">git pull origin main</span><br></pre></td></tr></table></figure><p>使用 <code>git pull</code> 可以方便地将远程仓库的内容同步到本地，但在大多数情况下，直接使用 <code>git clone</code> 会更简单，因为它自动完成了初始化和配置远程仓库的步骤。</p><h2 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h2><ol><li><p><strong>导航到本地项目目录</strong>：</p><ul><li>使用 <code>cd</code> 命令导航到你的本地项目目录。例如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/to/your/project</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>初始化 Git 仓库</strong>：</p><ul><li>如果你还没有初始化 Git 仓库，可以使用以下命令初始化：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>添加文件到暂存区</strong>：</p><ul><li>使用 <code>git add</code> 命令将本地项目文件添加到 Git 暂存区：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>这里的 <code>.</code> 表示添加当前目录下的所有文件。</li></ul></li><li><p><strong>提交更改</strong>：</p><ul><li>使用 <code>git commit</code> 命令提交更改并添加提交信息方便大家知道你上传的是什么：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;这是写信息&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>推送到远程仓库</strong>：</p><ul><li>使用 <code>git push</code> 命令将本地仓库的提交推送到 GitHub 上的远程仓库：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>如果你的默认分支是 <code>master</code> 而不是 <code>main</code>，请相应地更改命令中的分支名。</li></ul></li></ol><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>认证问题</strong>：使用 HTTPS URL 时，可能需要输入 GitHub 账号的用户名和密码。如果你设置了双因素认证，你需要生成一个 <a href="https://github.com/settings/tokens">GitHub 个人访问令牌</a> 作为密码使用。使用 SSH URL 时，需要配置 SSH 密钥对。</li><li><strong>推送分支</strong>：确保你推送到正确的分支（通常是 <code>main</code> 或 <code>master</code>）。</li></ul><details class="folding-tag" ><summary> 如何查看默认分支 </summary>              <div class='content'>              <h3 id="查看默认分支"><a href="#查看默认分支" class="headerlink" title="查看默认分支"></a>查看默认分支</h3><h4 id="查看本地仓库的默认分支"><a href="#查看本地仓库的默认分支" class="headerlink" title="查看本地仓库的默认分支"></a>查看本地仓库的默认分支</h4><p>查看和更改 Git 仓库的默认分支是 Git 使用中的常见操作。以下是如何查看和设置默认分支的步</p><ol><li><p>使用 <code>git branch</code> 命令：</p><ul><li><p>打开终端或命令行，导航到你的本地 Git 仓库。</p></li><li><p>使用以下命令查看所有本地分支，并标记当前检出的分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">复制代码</span><br><span class="line">git branch</span><br></pre></td></tr></table></figure><p>输出中，带有 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*</span><br></pre></td></tr></table></figure><p> 的分支是当前检出的分支，通常也是默认分支。</p></li></ul></li></ol><h4 id="查看远程仓库的默认分支"><a href="#查看远程仓库的默认分支" class="headerlink" title="查看远程仓库的默认分支"></a>查看远程仓库的默认分支</h4><ol><li><p>使用 <code>git remote show origin</code> 命令：</p><ul><li><p>在你的本地仓库目录中，使用以下命令查看远程仓库的信息，包括默认分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote show origin</span><br></pre></td></tr></table></figure><p>在输出中，你会看到类似以下信息：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* <span class="selector-tag">remote</span> <span class="selector-tag">origin</span></span><br><span class="line">  <span class="selector-tag">Fetch</span> <span class="selector-tag">URL</span>: <span class="selector-tag">https</span>:<span class="comment">//github.com/your-username/your-repository.git</span></span><br><span class="line">  <span class="selector-tag">Push</span> <span class="selector-tag">URL</span>: <span class="selector-tag">https</span>:<span class="comment">//github.com/your-username/your-repository.git</span></span><br><span class="line">  <span class="selector-tag">HEAD</span> <span class="selector-tag">branch</span>: <span class="selector-tag">main</span></span><br></pre></td></tr></table></figure><p>HEAD branch 字段表示远程仓库的默认分支。</p></li></ul></li></ol>              </div>            </details><details class="folding-tag" ><summary> 创建新的默认分支 </summary>              <div class='content'>              <h3 id="设置默认分支"><a href="#设置默认分支" class="headerlink" title="设置默认分支"></a>设置默认分支</h3><h4 id="更改本地仓库的默认分支"><a href="#更改本地仓库的默认分支" class="headerlink" title="更改本地仓库的默认分支"></a>更改本地仓库的默认分支</h4><ol><li><p><strong>创建新分支（如果需要）</strong>：</p><ul><li><p>如果你需要将默认分支改为一个新分支，首先创建该分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b new-default-branch</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>切换到要设为默认的分支</strong>：</p><ul><li><p>切换到你希望设置为默认的分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout desired-default-branch</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>删除旧的默认分支（可选）</strong>：</p><ul><li><p>如果需要删除旧的默认分支（例如 <code>main</code> 或 <code>master</code>），确保你已经在另一个分支上，并且没有未提交的更改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d old-default-branch</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="更改远程仓库的默认分支"><a href="#更改远程仓库的默认分支" class="headerlink" title="更改远程仓库的默认分支"></a>更改远程仓库的默认分支</h4><ol><li><p><strong>推送新的默认分支到远程仓库</strong>：</p><ul><li><p>将新的默认分支推送到远程仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin new-default-branch</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>更改 GitHub 上的默认分支设置</strong>：</p><ul><li>登录到你的 GitHub 账号，并导航到你的仓库页面。</li><li>点击仓库名称下方的 <code>Settings</code> 标签。</li><li>在左侧菜单中选择 <code>Branches</code>。</li><li>在 <code>Default branch</code> 部分，点击 <code>Change default branch</code> 按钮。</li><li>选择新的默认分支，然后点击 <code>Update</code>。</li></ul></li><li><p><strong>删除远程旧的默认分支（可选）</strong>：</p><ul><li><p>如果需要删除远程的旧默认分支，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete old-default-branch</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="示例操作"><a href="#示例操作" class="headerlink" title="示例操作"></a>示例操作</h3><p>假设你想将默认分支从 <code>master</code> 改为 <code>main</code>。以下是完整操作示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建新的默认分支（如果需要）</span></span><br><span class="line">git checkout -b main</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送新的默认分支到远程仓库</span></span><br><span class="line">git push -u origin main</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录到 GitHub，导航到仓库设置并更改默认分支为 main</span></span><br><span class="line"><span class="comment"># 删除旧的默认分支（可选）</span></span><br><span class="line">git branch -d master</span><br><span class="line">git push origin --delete master</span><br></pre></td></tr></table></figure><p>通过这些步骤，你可以查看和更改 Git 仓库的默认分支，以满足你的开发需求。</p>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法</title>
      <link href="/2024/05/22/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
      <url>/2024/05/22/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><h2 id="贪心算法基本概念"><a href="#贪心算法基本概念" class="headerlink" title="贪心算法基本概念"></a>贪心算法基本概念</h2><p>贪心算法（又称贪婪算法）是指，在对<a href="https://baike.baidu.com/item/问题求解/6693186">问题求解</a>时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部<a href="https://baike.baidu.com/item/最优解/5208902">最优解</a>。</p><p>贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。</p><h2 id="贪心算法基本思路"><a href="#贪心算法基本思路" class="headerlink" title="贪心算法基本思路"></a>贪心算法基本思路</h2><ul><li>基本思想</li></ul><p>贪心算法的基本思路是从问题的某一个初始解出发一步一步地进行，根据某个优化测度，每一步都要确保能获得局部最优解。每一步只考虑一个数据，他的选取应该满足局部优化的条件。若下一个数据和部分最优解连在一起不再是可行解时，就不把该数据添加到部分解中，直到把所有数据枚举完，或者不能再添加算法停止 。</p><ul><li>贪心算法过程<ul><li>建立数学模型来描述问题；</li><li>把求解的问题分成若干个子问题；</li><li>对每一子问题求解，得到子问题的局部最优解；</li><li>把子问题的解局部最优解合成原来解问题的一个解。</li></ul></li></ul><h2 id="适合解决问题"><a href="#适合解决问题" class="headerlink" title="适合解决问题"></a>适合解决问题</h2><p>l 适用问题  </p><p>​    贪心策略适用的前提是：局部最优策略能导致产生全局最优解。</p><p>l 实现框架</p><p>   从问题的某一初始解出发；</p><p>​    while （能朝给定总目标前进一步）</p><p>​    { </p><p>​      利用可行的决策，求出可行解的一个解元素；</p><p>​    }</p><p>   由所有解元素组合成问题的一个可行解；</p><p>l 贪心策略的选择</p><p>用贪心算法只能通过解局部最优解的策略来达到全局最优解，因此，一定要注意判断问题是否适合采用贪心算法策略，找到的解是否一定是问题的最优解。</p><h2 id="贪心算法的步骤"><a href="#贪心算法的步骤" class="headerlink" title="贪心算法的步骤"></a>贪心算法的步骤</h2><ol><li><p>根据题意，确定贪心策略（局部最优能够到达全局最优）</p></li><li><p>整理数据</p></li><li><p>根据策略逐个搜索，得到问题的解</p></li><li><p>输出结果</p></li></ol><h1 id="经典贪心"><a href="#经典贪心" class="headerlink" title="经典贪心"></a>经典贪心</h1><h2 id="最优装载问题"><a href="#最优装载问题" class="headerlink" title="最优装载问题"></a>最优装载问题</h2><p>贪心策略：先装最轻的。（不一定得到全局最优解）</p><p>有n个物体，第i个物体的重量为wi（wi为正整数）。选择尽量多的物体，使得总重量不超过C。</p><blockquote><p><strong>算法分析</strong></p><p>由于只关心选择的物品的最大数量（而不是最大重量，最大重量需要考虑动态规划DP），所以装重的物体没有装轻的物体划算。这里只需对n个物体按重量递增排序，依次选择每个物体直到装不下为止。</p><p> 这是一种典型的贪心算法，它只顾眼前，却能得到最优解。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n,c,w[<span class="number">10001</span>];<span class="comment">//n物体个数c总重量</span></span><br><span class="line">cin&gt;&gt;n&gt;&gt;c;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;w[i];</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">sort</span>(w,w+n);</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(sum+w[i]&lt;=c)&#123;</span><br><span class="line">ans++;</span><br><span class="line">sum+=w[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="sort函数的原理"><a href="#sort函数的原理" class="headerlink" title="sort函数的原理"></a><code>sort</code>函数的原理</h3><p><code>sort</code>函数使用一种高效的排序算法（如快速排序、堆排序或内省排序）来对元素进行排序。内省排序（Introsort）是C++标准库中常用的排序算法，它结合了快速排序、堆排序和插入排序，能够在大多数情况下提供快速排序的效率，同时避免了最坏情况下的性能问题。</p><h4 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h4><ol><li><strong>快速排序（Quick Sort）</strong>：一种分而治之的排序算法，平均情况下具有O(n log n)的时间复杂度，但在最坏情况下会退化为O(n^2)。</li><li><strong>堆排序（Heap Sort）</strong>：基于二叉堆的数据结构，具有O(n log n)的时间复杂度，即使在最坏情况下也能保证这个时间复杂度。</li><li><strong>插入排序（Insertion Sort）</strong>：对于小规模数据或几乎已排好序的数据非常高效，具有O(n^2)的时间复杂度，但在小数据集时表现良好。</li></ol><p>内省排序的工作流程如下：</p><ul><li>首先使用快速排序对数据进行排序。</li><li>如果快速排序递归深度过大，可能导致最坏情况的出现，此时切换到堆排序。</li><li>在排序的最后阶段，当子序列长度较小时，使用插入排序完成排序。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>sort(w, w+n)是一种高效、简单的方式，用于对C++数组进行排序。它利用了内省排序算法的优势，保证了大多数情况下的高效性和最坏情况下的稳定性能。通过指定数组的开始和结束指针，可以方便地对数组进行排序，并且可以通过自定义比较函数实现不同的排序规则。</p><h1 id="一维贪心"><a href="#一维贪心" class="headerlink" title="一维贪心"></a>一维贪心</h1><h2 id="P23004排队打水问题"><a href="#P23004排队打水问题" class="headerlink" title="P23004排队打水问题"></a>P23004排队打水问题</h2><p>有N个人排队到R个水龙头去打水，他们装满水桶的时间为T1，T2，…，Tn为整数且各（1）不相等，应如何安排他们的打水顺序才能使他们花费的时间最少？</p><p><strong><em>\</em>【算法分析】**</strong></p><p>由于排队时，越靠前面的计算的次数越多，显然越小的排在越前面得出的结果越小（可以用数学方法简单证明，这里就不再赘述），所以这道题可以用贪心法解答，基本步骤：</p><ol><li><p>将输入的时间按从小到大排序；</p></li><li><p>将排序后的时间按顺序依次放入每个水龙头的队列中；   </p></li><li><p>统计，输出答案。</p><ul><li><p>2 1</p></li><li><p>5 10</p></li></ul></li></ol><p><strong><em>\</em>贪心策略：使前面的人等的时间最短**</strong></p><p><strong>【参考程序】</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10005</span>];</span><br><span class="line"><span class="type">int</span> s[<span class="number">105</span>];</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n,r,i,j=<span class="number">0</span>,minx=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;r); </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a,a+n);<span class="comment">//排序,从小到大的顺序接水  </span></span><br><span class="line">   <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;++i)  &#123;    <span class="comment">//用贪心法求解   </span></span><br><span class="line">      j++;</span><br><span class="line">      <span class="keyword">if</span> (j==r+<span class="number">1</span>) j=<span class="number">1</span>;   <span class="comment">//前r个人为一组，第r+1个人回到第一个水龙 </span></span><br><span class="line">      s[j]+=a[i];     <span class="comment">//当前j龙头：接水时间加上等待时间 </span></span><br><span class="line">      minx+=s[j];</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,minx);   <span class="comment">//输出解答</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间复杂度</title>
      <link href="/2024/05/21/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>/2024/05/21/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="时间复杂度估算方法"><a href="#时间复杂度估算方法" class="headerlink" title="时间复杂度估算方法"></a>时间复杂度估算方法</h2><ul><li>简单语句</li></ul><p>简单的赋值语句，读写语句，可以看作所用时间为常量记为O(1)。</p><ul><li><p>分支语句</p><p>在分支语句中，以所耗费时间最多的那个分支来计算时间复杂度。</p></li><li><p>循环语句</p></li></ul><p>在循环语句中，每循环1次记为O(1)，循环n次时间复杂度为O(n)。</p><ul><li>嵌套循环</li></ul><p>在嵌套循环中，时间复杂度是多个循环的叠加，如下所示：</p><p>在嵌套循环中，时间复杂度</p><div class="table-container"><table><thead><tr><th>for(int i=1;i&lt;=n;i++)   for(int j=1;j&lt;=n;j++) …….</th><th>O(n*n)=O(n^2)</th></tr></thead><tbody><tr><td>for(int i=1;i&lt;=n;i++)   for(int j=1;j&lt;=n;j++)    for(int k=1;k&lt;=n;i++)     …….</td><td>O(n*n)=O(n^3)</td></tr><tr><td>for(int i=1;i&lt;=n;i++)   {for(int j=1;j&lt;=n;j++){…..}    for(int k=1;k&lt;=n;i++){     …….}}</td><td>O(n<em>n)=O(2</em>n^2)</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
